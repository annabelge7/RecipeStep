{"ast":null,"code":"import * as React from \"rehackt\";\nimport { getWrappedPromise, unwrapQueryRef, updateWrappedQueryRef, wrapQueryRef } from \"../internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { wrapHook } from \"./internal/index.js\";\n/**\n * A React hook that returns a `refetch` and `fetchMore` function for a given\n * `queryRef`.\n *\n * This is useful to get access to handlers for a `queryRef` that was created by\n * `createQueryPreloader` or when the handlers for a `queryRef` produced in\n * a different component are inaccessible.\n *\n * @example\n * ```tsx\n * const MyComponent({ queryRef }) {\n *   const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n *\n *   // ...\n * }\n * ```\n * @since 3.9.0\n * @param queryRef - A `QueryReference` returned from `useBackgroundQuery`, `useLoadableQuery`, or `createQueryPreloader`.\n */\nexport function useQueryRefHandlers(queryRef) {\n  var unwrapped = unwrapQueryRef(queryRef);\n  return wrapHook(\"useQueryRefHandlers\", _useQueryRefHandlers, unwrapped ? unwrapped[\"observable\"]\n  // in the case of a \"transported\" queryRef object, we need to use the\n  // client that's available to us at the current position in the React tree\n  // that ApolloClient will then have the job to recreate a real queryRef from\n  // the transported object\n  : useApolloClient())(queryRef);\n}\nfunction _useQueryRefHandlers(queryRef) {\n  var _a = React.useState(queryRef),\n    previousQueryRef = _a[0],\n    setPreviousQueryRef = _a[1];\n  var _b = React.useState(queryRef),\n    wrappedQueryRef = _b[0],\n    setWrappedQueryRef = _b[1];\n  var internalQueryRef = unwrapQueryRef(queryRef);\n  // To ensure we can support React transitions, this hook needs to manage the\n  // queryRef state and apply React's state value immediately to the existing\n  // queryRef since this hook doesn't return the queryRef directly\n  if (previousQueryRef !== queryRef) {\n    setPreviousQueryRef(queryRef);\n    setWrappedQueryRef(queryRef);\n  } else {\n    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));\n  }\n  var refetch = React.useCallback(function (variables) {\n    var promise = internalQueryRef.refetch(variables);\n    setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n    return promise;\n  }, [internalQueryRef]);\n  var fetchMore = React.useCallback(function (options) {\n    var promise = internalQueryRef.fetchMore(options);\n    setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n    return promise;\n  }, [internalQueryRef]);\n  return {\n    refetch: refetch,\n    fetchMore: fetchMore\n  };\n}","map":{"version":3,"names":["React","getWrappedPromise","unwrapQueryRef","updateWrappedQueryRef","wrapQueryRef","useApolloClient","wrapHook","useQueryRefHandlers","queryRef","unwrapped","_useQueryRefHandlers","_a","useState","previousQueryRef","setPreviousQueryRef","_b","wrappedQueryRef","setWrappedQueryRef","internalQueryRef","refetch","useCallback","variables","promise","fetchMore","options"],"sources":["/Users/annabeledwards/Desktop/FullStack/project2/project-2-recipe-step-tracker-v2-annabelge7/frontend/node_modules/@apollo/src/react/hooks/useQueryRefHandlers.ts"],"sourcesContent":["import * as React from \"rehackt\";\nimport {\n  getWrappedPromise,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"../internal/index.js\";\nimport type {\n  InternalQueryReference,\n  QueryReference,\n} from \"../internal/index.js\";\nimport type { OperationVariables } from \"../../core/types.js\";\nimport type { RefetchFunction, FetchMoreFunction } from \"./useSuspenseQuery.js\";\nimport type { FetchMoreQueryOptions } from \"../../core/watchQueryOptions.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { wrapHook } from \"./internal/index.js\";\n\nexport interface UseQueryRefHandlersResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  /** {@inheritDoc @apollo/client!ObservableQuery#refetch:member(1)} */\n  refetch: RefetchFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#fetchMore:member(1)} */\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n}\n\n/**\n * A React hook that returns a `refetch` and `fetchMore` function for a given\n * `queryRef`.\n *\n * This is useful to get access to handlers for a `queryRef` that was created by\n * `createQueryPreloader` or when the handlers for a `queryRef` produced in\n * a different component are inaccessible.\n *\n * @example\n * ```tsx\n * const MyComponent({ queryRef }) {\n *   const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n *\n *   // ...\n * }\n * ```\n * @since 3.9.0\n * @param queryRef - A `QueryReference` returned from `useBackgroundQuery`, `useLoadableQuery`, or `createQueryPreloader`.\n */\nexport function useQueryRefHandlers<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryReference<TData, TVariables>\n): UseQueryRefHandlersResult<TData, TVariables> {\n  const unwrapped = unwrapQueryRef(\n    queryRef\n  ) satisfies InternalQueryReference<TData> as /*\n    by all rules of this codebase, this should never be undefined\n    but if `queryRef` is a transported object, it cannot have a\n    `QUERY_REFERENCE_SYMBOL` symbol property, so the call above\n    will return `undefined` and we want that represented in the type\n    */ InternalQueryReference<TData> | undefined;\n\n  return wrapHook(\n    \"useQueryRefHandlers\",\n    _useQueryRefHandlers,\n    unwrapped ?\n      unwrapped[\"observable\"]\n      // in the case of a \"transported\" queryRef object, we need to use the\n      // client that's available to us at the current position in the React tree\n      // that ApolloClient will then have the job to recreate a real queryRef from\n      // the transported object\n    : useApolloClient()\n  )(queryRef);\n}\n\nfunction _useQueryRefHandlers<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryReference<TData, TVariables>\n): UseQueryRefHandlersResult<TData, TVariables> {\n  const [previousQueryRef, setPreviousQueryRef] = React.useState(queryRef);\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(queryRef);\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  // To ensure we can support React transitions, this hook needs to manage the\n  // queryRef state and apply React's state value immediately to the existing\n  // queryRef since this hook doesn't return the queryRef directly\n  if (previousQueryRef !== queryRef) {\n    setPreviousQueryRef(queryRef);\n    setWrappedQueryRef(queryRef);\n  } else {\n    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));\n  }\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = internalQueryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = internalQueryRef.fetchMore(\n        options as FetchMoreQueryOptions<any, any>\n      );\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  return { refetch, fetchMore };\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,SAAS;AAChC,SACEC,iBAAiB,EACjBC,cAAc,EACdC,qBAAqB,EACrBC,YAAY,QACP,sBAAsB;AAQ7B,SAASC,eAAe,QAAQ,sBAAsB;AACtD,SAASC,QAAQ,QAAQ,qBAAqB;AAY9C;;;;;;;;;;;;;;;;;;;AAmBA,OAAM,SAAUC,mBAAmBA,CAIjCC,QAA2C;EAE3C,IAAMC,SAAS,GAAGP,cAAc,CAC9BM,QAAQ,CAMoC;EAE9C,OAAOF,QAAQ,CACb,qBAAqB,EACrBI,oBAAoB,EACpBD,SAAS,GACPA,SAAS,CAAC,YAAY;EACtB;EACA;EACA;EACA;EAAA,EACAJ,eAAe,EAAE,CACpB,CAACG,QAAQ,CAAC;AACb;AAEA,SAASE,oBAAoBA,CAI3BF,QAA2C;EAErC,IAAAG,EAAA,GAA0CX,KAAK,CAACY,QAAQ,CAACJ,QAAQ,CAAC;IAAjEK,gBAAgB,GAAAF,EAAA;IAAEG,mBAAmB,GAAAH,EAAA,GAA4B;EAClE,IAAAI,EAAA,GAAwCf,KAAK,CAACY,QAAQ,CAACJ,QAAQ,CAAC;IAA/DQ,eAAe,GAAAD,EAAA;IAAEE,kBAAkB,GAAAF,EAAA,GAA4B;EACtE,IAAMG,gBAAgB,GAAGhB,cAAc,CAACM,QAAQ,CAAC;EAEjD;EACA;EACA;EACA,IAAIK,gBAAgB,KAAKL,QAAQ,EAAE;IACjCM,mBAAmB,CAACN,QAAQ,CAAC;IAC7BS,kBAAkB,CAACT,QAAQ,CAAC;EAC9B,CAAC,MAAM;IACLL,qBAAqB,CAACK,QAAQ,EAAEP,iBAAiB,CAACe,eAAe,CAAC,CAAC;EACrE;EAEA,IAAMG,OAAO,GAAuCnB,KAAK,CAACoB,WAAW,CACnE,UAACC,SAAS;IACR,IAAMC,OAAO,GAAGJ,gBAAgB,CAACC,OAAO,CAACE,SAAS,CAAC;IAEnDJ,kBAAkB,CAACb,YAAY,CAACc,gBAAgB,CAAC,CAAC;IAElD,OAAOI,OAAO;EAChB,CAAC,EACD,CAACJ,gBAAgB,CAAC,CACnB;EAED,IAAMK,SAAS,GAAyCvB,KAAK,CAACoB,WAAW,CACvE,UAACI,OAAO;IACN,IAAMF,OAAO,GAAGJ,gBAAgB,CAACK,SAAS,CACxCC,OAA0C,CAC3C;IAEDP,kBAAkB,CAACb,YAAY,CAACc,gBAAgB,CAAC,CAAC;IAElD,OAAOI,OAAO;EAChB,CAAC,EACD,CAACJ,gBAAgB,CAAC,CACnB;EAED,OAAO;IAAEC,OAAO,EAAAA,OAAA;IAAEI,SAAS,EAAAA;EAAA,CAAE;AAC/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}